# 객체 지향 프로그래밍

**2025/02/10 [포텐업] 게임 개발자 양성 과정**

---

## 객체 지향 프로그래밍 기초

### 상속

**중복되는 코드를 제거하고, 코드의 재사용성을 높이는 대표적인 방법 중 하나**

- 공통 기능 및 변수를 부모 클래스에 선언하고, 이를 상속하는 자식 클래스에서는 부모에서 허용한(public/protected) 변수 및 메소드를 사용할 수 있다.
- 이를 통해 코드의 재사용성을 증가시킬 수 있다.
- **하지만, 상속을 많이 사용하면 그 자체로 계층 구조가 발생하기 때문에 복잡도가 증가한다.**



### 정보 은닉

객체 지향 프로그래밍에서 여러 객체들 간의 의사소통은 메시지를 통해서 하는 것이 원칙이다. 따라서, 어떤 객체의 상태를 나타내는 멤버 변수는 외부에서 감추는 것이 좋다.

**객체 자신의 상태를 외부에서 직접 변경할 수 없게 감추는 것**

C++에서는 private 한정자(접근 제한자, 접근 수정자, Visibility)를 통해서 외부에서 접근이 불가능하도록 선언할 수 있다.

- **public 한정자** : 외부에서 접근이 가능하도록 선언할 때 사용한다.
- **protected 한정자** : 외부에서는 접근이 불가능하지만, 자기 자신과 자식 계층까지는 사용이 가능하다.
- **private 한정자** : 자기 자신만 접근이 가능해야 할 때 사용한다. 따라서 자식 계층도 접근이 불가하다.

객체의 멤버 변수를 private(또는 protected)로 선언하고, getter와 setter를 사용해 외부에서 접근하도록 처리하는 방법이 일반적으로 활용된다.



### 다형성

**어떤 타입을 다른 타입으로도 다룰 수 있는 성질**

보통 자식 클래스를 부모 클래스 타입으로 다루는 방식이 일반적으로 활용된다. (C++에서는 이 방식 밖에 없다.)

언리얼 엔진의 경우 엔진 내부에서 모든 액터(Actor)와 컴포넌트(Component)들을 관리해야 하는데, 이때 액터와 컴포넌트의 부모 클래스인 Actor / Component 클래스로 참조해 관리한다.



#### 형 변환

업 캐스팅

* 자식 클래스에서 부모 클래스로의 형변환을 의미하며, 언제나 성공한다.
* 자식 클래스 타입을 부모 클래스 타입의 변수에 참조하는 방식이며, 굉장히 일반적으로 자주 사용되는 방식이다.
* 자식 클래스 타입을 부모 클래스 타입으로 참조하면, 자식 클래스만 가진 변수 및 메소드는 사용할 수 없고, 부모 클래스로부터 상속 받은 범위까지 사용이 가능하다.

다운 캐스팅

- 부모 클래스에서 자식 클래스로의 형변환을 의미하며, 상황에 따라 형변환에 성공할 수도 있고, 실패할 수도 있다.
- 부모 클래스에 대입된 실제 메모리 공간의 데이터가 형변환 하려는 자식 클래스 타입이라면 형변환에 성공하고, 그렇지 않다면 형변환에 실패한다. (실패하면 null 반환).
- 명시적으로 형변환을 해야한다.
- 형변환에 실패할 수 있기 때문에 다운 캐스팅을 할 때는 항상 형변환을 진행한 뒤에 해당 객체가 null인지 아닌지를 확인하는 과정이 필수다.



#### dynamic_cast 형변환 연산자

계층 구조를 가진 객체에서 다운 캐스팅을 진행해야 할 때는 런타임에 타입을 확인할 수 있는 dynamic_cast 연산자를 사용해야 한다.

형변환을 시도한 뒤 실패하면 null을 반환하며 vtable을 가진 객체에서만 동작한다. 따라서 계층 구조를 가진 객체에서만 사용해야 한다.



#### RTTI 직접 구현

dynamic_cast를 사용해 다운 캐스팅을 처리할 수 있지만, dynamic_cast의 최대 단점은 속도가 느리다는 점이다. 간헐적으로 많이 사용하지 않는 경우에는 문제가 되지 않겠지만, 빈번하게 사용할 경우에는 느린 속도로 인해 문제가 발생할 수 있다.



## 상속 기반 확장

### 합성과 집합

#### 연관

시스템 내의 두 개체 간의 유연하게 **"거리를 두는"** 관계다.

관계의 방향에 대한 특별한 제약이 없다.

#### 합성

어느 클래스의 생명 주기를 다른 한 클래스가 직접 관리하며 이런 클래스 간의 관계를 **합성**이라고 부른다.

생성은 다른 곳에서 하고 소멸만 관리하는 경우도 또 다른 종류의 합성 관계로 볼 수 있다.

#### 집합

생성과 소멸(즉, 수명)을 직접 관리하지 않는 관계도 있는데 객체 지향에선 이런 관계를 **집합**이라고 한다.

물론, 이런 용어와 우리가 작성하는 코드 사이의 엄격한 규칙은 없다.
