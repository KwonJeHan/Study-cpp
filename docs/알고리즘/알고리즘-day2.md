# 알고리즘 학습 정리

**2025/02/10 [포텐업] 게임 개발자 양성 과정**

---

## 정렬

### 버블 정렬

인접한 두 원소를 비교하여 필요에 따라 서로 위치를 교환하는 방식으로 동작한다. 가장 큰(또는 가장 작은) 원소가 배열의 가장 마지막으로 이동하면서 정렬이 완료된다.



#### 버블 정렬 동작 방식

1. 배열의 첫 번째 원소부터 마지막 원소까지 순회한다.
2. 현재 원소와 다음 원소를 비교하여 크기가 더 작은(또는 더 큰) 원소가 앞에 오도록 위치를 교환한다.
3. 배열의 마지막 위치까지 도달할 때까지 위의 과정을 반복한다.
4. 한 번의 순회를 마치면 가장 큰(또는 가장 작은) 원소가 배열의 마지막으로 이동하게 되므로, 다음 순회에서는 마지막 원소를 제외한 나머지 원소에 대해 동일한 과정을 반복한다.
5. 모든 원소가 정렬될 때까지 위의 과정을 반복한다.



#### 버블 정렬 시간 복잡도

- 최선의 경우: O(n) - 이미 정렬되어 있는 배열의 경우
- 평균 및 최악의 경우: O(n^2) - 배열의 크기에 따라 비효율적인 경우가 발생할 수 있음



### 선택 정렬

제자리 정렬 알고리즘의 하나로 주어진 리스트에서 가장 작은 값을 찾아 맨 앞으로 이동 시키는 과정을 반복하여 정렬하는 알고리즘이다. 이 과정을 통해 리스트는 작은 값부터 큰 값 순서대로 정렬된다.

자료 이동 횟수가 미리 결정되는 장점이 있지만 값이 같은 레코드가 있는 경우에 상대적인 위치가 변경될 수 있어 안정성을 만족하지 않는 단점이 있다.



#### 선택 정렬 동작 방식

1. 주어진 리스트에서 가장 작은 값을 찾는다.
2. 해당 값을 리스트의 맨 앞 원소와 교환한다.
3. 리스트의 첫 번째 원소를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
4. 모든 원소가 정렬될 때까지 위의 과정을 반복한다.



#### 선택 정렬 시간 복잡도

- **최선, 평균, 최악의 경우 모두 O(n^2)이다. 따라서 선택 정렬은 대부분의 경우 효율적인 정렬 알고리즘이 아니다.**
- 비교 횟수
  - 두 개의 for 루프의 실행 횟수
  - 외부 루프: (n-1)번
  - 내부 루프(최솟값 찾기): n-1, n-2, … , 2, 1 번
- 교환 횟수
  - 외부 루프의 실행 횟수와 동일. 즉, 상수 시간 작업
  - 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 3(n-1)번
- T(n) = (n-1)+(n-2)+...2+1={n(n-1)\over 2}=O(n^2)



### 삽입 정렬

주어진 리스트를 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 적절한 위치에 삽입하여 정렬하는 알고리즘



#### 삽입 정렬 동작 방식

1. 주어진 리스트를 정렬된 부분과 정렬되지 않은 부분으로 나눈다.
2. 정렬되지 않은 부분의 첫 번째 원소를 정렬된 부분의 적절한 위치에 삽입한다.
3. 나머지 정렬되지 않은 부분의 원소를 하나씩 정렬된 부분에 삽입한다.
4. 모든 원소가 정렬될 때까지 위의 과정을 반복한다.



#### 삽입 정렬 시간 복잡도

- 최선의 경우(이미 정렬된 배열): O(n)
- 최악의 경우(역순으로 정렬된 배열): O(n^2)
- 평균적인 경우: O(n^2)



### 퀵 정렬

분한 정복 알고리즘 중 하나로, 평균적으로 가장 빠른 정렬 알고리즘 중 하나이다.

리스트를 분할하고 각 부분을 재귀적으로 정렬하여 전체 리스트를 정렬하는 방식이다.



#### 퀵 정렬 동작 방식

1. 기준점(pivot)을 선택한다. 보통 리스트의 중간 값을 선택한다.
2. 기준점을 기준으로 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 분할한다.
3. 분할된 부분 리스트에 대해 재귀적으로 위의 과정을 반복한다.
4. 부분 리스트의 크기가 1 이하가 될 때까지 분할과 정렬을 반복한다.



#### 퀵 정렬 시간 복잡도

- 평균 및 최선의 경우: O(nlogn)
- 최악의 경우(이미 정렬된 리스트): O(n^2)



#### 퀵 정렬 구현 시 고민 사항

기준 요소의 선택

* 선택 방법 중 쓸만한 것 한 가지는 데이터 집합에서 무작위로 기준 요소를 선택하는 방식 -> 최소 값이나 최대 값이 선택되는 확률을 크게 줄일 수 있다. 하지만 무작위로 선택하기 위한 난수를 뽑아내는 과정에서 성능 저하가 생긴다.
* 더 좋은 방법은 데이터 집합의 처음 세 개 요소 중에서 중간 값을 기준 요소로 지정하는 것이다. 이렇게 하면 처음 세 개 중의 중간 값을 찾기 위한 아주 작은 성능 비용을 지출하긴 하지만, 최악의 경우를 항상 피할 수 있다.

배열을 데이터 집합의 자료구조로 사용할 때, 분할은 어떻게 수행해야 하는가?(링크드 리스트처럼 삽입/삭제가 자유롭지 못하므로)

- 공간을 더 사용하기 보다는 인덱스 두 개를 사용해서 분할 로직을 구현한다.
- 왼쪽에서 오른쪽으로 이동하는 인덱스와 오른쪽에서 왼쪽으로 이동하는 인덱스를 사용한다.
- 왼쪽에서 오른쪽으로 이동하는 인덱스는 기준보다 큰 요소를 찾고, 오른쪽에서 왼쪽으로 이동하는 인덱스는 기준보다 작은 요소를 찾아 서로 교환한다.
- 두 인덱스가 서로 만나거나 교차할 때까지 위의 과정을 반복한다.
- 두 인덱스가 서로 만나거나 교차하면 기준 값을 왼쪽 데이터 마지막 요소와 교환한다.

반복되는 분할 과정을 어떻게 처리할 것인가?

- 재귀 함수를 사용하면 반복되는 과정을 효과적으로 처리할 수 있다.
