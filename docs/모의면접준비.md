## 단계 1 : 기초 언어 및 시스템 이해

### C언어와 C++의 차이점 및 C++의 특징

**C언어와 C++의 차이점은 무엇인가요? C++의 특징은 어떤 것이 있나요?**

C언어는 절차지향 프로그래밍 언어로, C++은 C언어에서 객체지향 프로그래밍을 지원하도록 확장된 언어입니다. 

C++의 주요 특징으로는

1. 객체지향 프로그래밍(캡슐화, 상속, 다형성) 지원
2. 수동 및 자동 메모리 관리(동적 메모리 할당, 스마트 포인터) 지원
3. 표준 라이브러리(STL)를 통한 다양한 자료구조와 알고리즘 제공
4. 템플릿을 통한 제네릭 프로그래밍 지원
   * 템플릿(Template)은 함수나 클래스의 정의에서 데이터 타입에 대한 매개변수화를 허용하는 기능입니다. 즉, 템플릿은 클래스나 함수를 작성할 때, 데이터 타입이나 상수 값을 매개변수로 받아서, 자동으로 여러 개의 타입이나 값에 동작하도록 하는 기능입니다.

게임 개발에서는 특히 성능이 중요한데, C++은 높은 성능과 함께 객체지향적 설계를 가능하게 하여 대규모 게임 시스템 구현에 적합합니다.



### C++의 형변환 방식

**C++의 형변환 방식(static_cast, reinterpret_cast 등)은 어떤 것이 있으며, 각각 언제 사용하는 것이 적절한가요?**

C++에서는 다양한 형변환 방식을 제공합니다

* static_cast : 컴파일 시간에 형 검사를 수행하는 가장 기본적인 형변환입니다. 관련 타입 간 변환(int에서 float, 부모 클래스에서 자식 클래스로의 다운캐스팅)에 사용합니다.

* dynamic_cast : 런타임에 형 검사를 수행하며, 주로 상속 계층 구조에서 안전한 다운캐스팅에 사용합니다. 실패 시 포인터는 nullptr을, 참조는 bad_cast 예외를 반환합니다.

* const_cast : const같은 타입 한정자를 제거할 때 사용합니다. 예를 들어, const 객체를 수정해야 하는 특수한 경우에 사용합니다.

* reinterpret_cast : 메모리의 비트 패턴을 재해석하는 형변환으로, 포인터 타입 간 변환이나 포인터와 정수 간 변환에 사용됩니다. 게임 개발에서는 하드웨어 접근이나 메모리 최적화 시 사용할 수 있지만, 매우 위험하므로 신중하게 사용해야 합니다.



### RValue와 LValue의 개념과 Universal Reference

**RValue와 LValue의 개념을 설명해보세요. Universal Reference는 무엇인가요?**

LValue는 메모리 주소를 가지는 표현식으로, 지속적으로 존재하는 객체를 가리킵니다. 변수명, 배열 요소, 참조 등이 LValue에 해당합니다.

RValue는 메모리 주소가 없는 임시 표현식으로, 표현식 평가 후 사라지는 임시 객체입니다. 리터럴, 임시 객체, 표현식의 결과 등이 RValue에 해당합니다.

Universal Reference(또는 Forwarding Reference)는 C++11에서 도입된 개념으로, T&& 형태로 선언되며 템플릿 매개변수 T가 타입 추론될 때 LValue와 RValue 모두를 참조할 수 있습니다. std::forward와 함께 사용되어 퍼펙트 포워딩(함수가 인자를 받아서 다른 함수에게 원본 인자를 완벽하게 전달하는 개념)을 구현하는데 활용됩니다.

게임 엔진에서는 성능이 중요하므로, 이동 의미론(move semantics)과 Universal Reference를 활용하여 불필요한 객체 복사를 줄이고 성능을 최적화할 수 있습니다.



### 메모리 영역 구분

**메모리는 어떤 영역으로 나뉘며 (Data, Code, Stack, Heap), 각각 어떤 데이터를 저장하나요?**

메모리는 주로 다음과 같은 영역으로 나뉩니다

* Code(Text) 영역 : 프로그램의 실행 코드가 저장되는 영역으로, 읽기 전용입니다.

* Data 영역 : 전역 변수, 정적(static) 변수가 저장되는 영역으로 다시 다음과 같이 구분됩니다:

  * 초기화된 데이터(initialized data): 명시적으로 초기화된 전역/정적 변수

  * 초기화되지 않은 데이터(BSS: Block Started by Symbol): 초기화되지 않은 전역/정적 변수

* Stack 영역 : 함수 호출 시 생성되는 지역 변수, 매개변수, 반환 주소 등이 저장되는 영역입니다. 함수 호출이 끝나면 자동으로 해제됩니다. 크기가 제한적이며 컴파일 시간에 크기가 결정되어야 합니다.

* Heap 영역 : 동적으로 할당되는 메모리 영역으로, new/malloc 등으로 할당하고 delete/free 등으로 해제해야 합니다. 프로그래머가 직접 관리해야 하며, 메모리 누수의 주요 원인이 될 수 있습니다.

게임 개발에서는 특히 Heap 영역의 관리가 중요합니다. 언리얼 엔진은 자체 메모리 할당자를 제공하여 효율적인 메모리 관리를 지원합니다.



### 프로세스와 스레드의 차이

**프로세스와 스레드의 차이는 무엇인가요? 게임 클라이언트 개발에서 어떻게 사용될 수 있을까요?**

프로세스는 실행 중인 프로그램의 인스턴스로, 독립된 메모리 공간과 시스템 자원을 가집니다. 스레드는 프로세스 내에서 실행되는 작업의 단위로, 같은 프로세스 내의 스레드들은 메모리 공간과 자원을 공유합니다.

주요 차이점은 아래와 같습니다.

* 프로세스는 독립된 메모리 공간을 가지지만, 스레드는 프로세스의 메모리를 공유합니다.

* 프로세스 간 통신은 IPC(Inter-Process Communication)을 통해 이루어지며 비용이 큽니다. 반면 스레드 간 통신은 공유 메모리를 통해 직접 이루어질 수 있어 더 효율적입니다.

* 프로세스 생성 및 컨텍스트 스위칭은 스레드보다 많은 비용이 듭니다.

게임 클라이언트 개발에서는 다음과 같이 활용됩니다

* 메인 스레드 : UI 처리, 사용자 입력 처리

* 렌더링 스레드 : 그래픽 렌더링 작업

* 물리 스레드 : 물리 시뮬레이션 계산

* 로딩 스레드 : 비동기 리소스 로딩

* 네트워크 스레드 : 서버와의 통신

언리얼 엔진은 멀티스레딩을 효과적으로 활용하여 성능을 최적화하며, Task 시스템을 통해 병렬 처리를 쉽게 구현할 수 있도록 지원합니다.



### 컨텍스트 스위칭

**컨텍스트 스위칭이 무엇인지 설명해보세요. 너무 자주 발생하면 어떤 문제가 생길 수 있나요?**

컨텍스트 스위칭은 CPU가 한 프로세스나 스레드에서 다른 프로세스나 스레드로 제어를 전환하는 과정입니다. 이 과정에서 현재 실행 중인 프로세스/스레드의 상태(레지스터 값, 프로그램 카운터 등)를 저장하고, 다음 실행할 프로세스/스레드의 상태를 복원합니다.

컨텍스트 스위칭이 너무 자주 발생하면 다음과 같은 문제가 생길 수 있습니다

* CPU 시간 낭비 : 컨텍스트 스위칭 자체가 CPU 시간을 소모합니다.

* 캐시 오염(Cache Pollution) : 이전 프로세스/스레드의 데이터가 캐시에 남아있어 캐시 효율성이 떨어집니다.

* TLB(Translation Lookaside Buffer) 플러시 : 메모리 주소 변환 정보가 지워져 메모리 접근 속도가 느려집니다.

* 전체적인 시스템 성능 저하 : 실제 작업보다 스위칭에 더 많은 시간을 소모할 수 있습니다.

게임 개발에서는 프레임 레이트 유지가 중요하므로, 메인 스레드에서 긴 작업을 수행하여 컨텍스트 스위칭을 유발하는 것을 피해야 합니다. 언리얼 엔진의 Task 시스템은 효율적인 작업 분배를 통해 불필요한 컨텍스트 스위칭을 최소화합니다.



### 데드락과 방지 방법

**데드락이란 무엇이며, 이를 방지하기 위해 어떤 방식으로 설계할 수 있을까요?**

데드락(교착 상태)은 두 개 이상의 프로세스나 스레드가 서로 상대방이 점유한 자원을 기다리며 무한정 대기하는 상태를 말합니다. 데드락이 발생하기 위한 네 가지 조건(Coffman 조건)은

1. 상호 배제(Mutual Exclusion) : 자원은 한 번에 하나의 프로세스만 사용할 수 있습니다.

2. 점유와 대기(Hold and Wait) : 자원을 보유한 채로 다른 자원을 요청할 수 있습니다.

3. 비선점(No Preemption) : 다른 프로세스가 자원을 강제로 빼앗을 수 없습니다.

4. 순환 대기(Circular Wait) : 프로세스들이 순환적으로 서로의 자원을 기다립니다.

데드락 방지를 위한 설계 방법

* 자원 할당 순서 정하기 : 모든 스레드가 동일한 순서로 자원을 요청하도록 하여 순환 대기를 방지합니다.

* 타임아웃 설정 : 락 획득 시도에 시간 제한을 두어 무한 대기를 방지합니다.

* 락 계층 구조(Lock Hierarchy) 사용 : 락에 우선순위를 부여하고 항상 낮은 우선순위에서 높은 우선순위 순으로 획득하도록 합니다.

* 두 단계 락킹(Two-Phase Locking) : 모든 락을 먼저 획득한 후에 작업을 수행하고, 작업이 끝나면 모든 락을 해제합니다.

* 락 없는 자료구조(Lock-Free Data Structures) 사용 : 원자적 연산을 활용하여 락 없이도 스레드 안전한 자료구조를 구현합니다.

게임 개발에서는 특히 렌더링, 물리, 네트워크 스레드 간의 자원 공유 시 데드락에 주의해야 합니다. 언리얼 엔진은 Task 시스템과 게임 스레드 모델을 통해 데드락 위험을 최소화하도록 설계되어 있습니다.

---

## 단계 2 : 메모리와 자료구조, 언리얼 타입 이해

### 스마트 포인터 사용  시점과 특징

**스마트 포인터는 언제 사용하면 좋을까요? unique_ptr, shared_ptr, weak_ptr 각각의 특징은 무엇인가요?**

스마트 포인터는 메모리 누수를 방지하고 자원 관리를 자동화하기 위해 사용합니다. 특히 예외 발생 시에도 안전하게 메모리를 해제할 수 있어 RAII(Resource Acquisition Is Initialization) 원칙을 구현하는 데 적합합니다.

unique_ptr : 단일 소유권 개념의 스마트 포인터로, 하나의 객체를 단 하나의 unique_ptr만 소유할 수 있습니다. 소유권 이전은 std::move()를 통해서만 가능하며, 소유자가 스코프를 벗어나면 자동으로 메모리가 해제됩니다. 오버헤드가 거의 없어 성능 상 raw 포인터와 비슷하므로 기본적으로 사용하기 좋은 스마트 포인터입니다.

shared_ptr : 공유 소유권 개념으로, 여러 shared_ptr이 하나의 객체를 공유할 수 있습니다. 내부적으로 참조 카운팅을 사용하여 마지막 shared_ptr이 소멸될 때 객체를 삭제합니다. 여러 곳에서 하나의 리소스에 접근해야 하는 경우에 유용하지만, 참조 카운트 관리로 인한 성능 오버헤드가 있습니다.

weak_ptr : shared_ptr과 함께 사용되지만 소유권을 갖지 않습니다. shared_ptr의 참조 카운트를 증가시키지 않으며, 객체가 아직 존재하는지 확인할 수 있는 lock() 메서드를 제공합니다. 순환 참조 문제를 해결하거나 캐시처럼 객체의 존재 여부를 확인해야 할 때 유용합니다.



### 스마트 포인터 순환 참조

**스마트 포인터를 사용할 때 순환 참조가 생길 수 있는데, 이 문제를 어떻게 해결할 수 있을까요?**

순환 참조는 두 객체가 서로 shared_ptr로 참조할 때 발생합니다. 이 경우 참조 카운트가 0이 되지 않아 메모리 누수가 발생할 수 있습니다.

해결 방법은 다음과 같습니다:

* weak_ptr 사용 : 한쪽 방향의 참조를 weak_ptr로 변경하여 순환 참조를 끊을 수 있습니다. weak_ptr은 참조 카운트를 증가시키지 않으므로 객체 수명에 영향을 주지 않습니다.

* 부모-자식 관계 설정 : 계층 구조에서는 부모가 자식을 shared_ptr로 소유하고, 자식은 부모를 weak_ptr로 참조하는 패턴을 사용합니다.

* 소멸자에서 참조 해제 : 객체의 소멸자에서 명시적으로 순환 참조를 끊어주는 방법도 있지만, 이는 스마트 포인터의 자동 관리 이점을 일부 상실합니다.

* 상호 참조가 필요한 구조 재설계 : 객체 간 상호 참조가 필요한지 다시 검토하고, 필요하다면 중재자 패턴 등을 활용해 직접적인 상호 참조를 피합니다.

실제 개발에서는 weak_ptr을 사용하는 방법이 가장 일반적이고 안전한 방법입니다.



### 언리얼 엔진 자료구조

**언리얼 엔진에서 자주 사용되는 자료구조(TArray, TMap, TSet, TQueue 등)에 대해 설명하고 어떤 상황에서 적합한지 예를 들어보세요.**

TArray : 언리얼의 동적 배열 구현체로, 메모리 연속성을 보장하며 빠른 순차 접근이 가능합니다. 요소 추가/제거 시 내부적으로 메모리 재할당이 일어날 수 있습니다. 적합한 상황으로는 플레이어의 인벤토리 아이템, 몬스터 스폰 위치 목록, 퀘스트 목록 등 순서가 중요하고 빈번한 순회가 필요한 경우에 적합합니다.

TMap : 키-값 쌍을 저장하는 해시맵으로, 키를 통한 빠른 검색이 가능합니다. 적합한 상황으로는 아이템 ID와 아이템 정보 매핑, 플레이어 ID와 플레이어 객체 매핑, 이벤트 타입과 핸들러 함수 매핑 등 고유 식별자를 통한 빠른 데이터 접근이 필요한 경우에 적합합니다.

TSet : 중복을 허용하지 않는 컬렉션으로, 원소 존재 여부를 빠르게 확인할 수 있습니다. 적합한 상황으로는 이미 방문한 지역 추적, 플레이어가 획득한 유니크 아이템 목록, 활성화된 특수 능력 목록 등 중복 제거와 빠른 멤버십 확인이 필요한 경우에 적합합니다.

TQueue : FIFO(First In, First Out) 구조의 큐로, 요소를 순서대로 처리할 때 사용합니다. 적합한 상황으로는 AI 명령 처리 대기열, 네트워크 패킷 처리 대기열, 애니메이션 시퀀스 처리 등 순서대로 처리해야 하는 작업들을 관리할 때 적합합니다.

TMultiMap : 하나의 키에 여러 값을 매핑할 수 있는 자료구조입니다. 적합한 상황으로는 이벤트에 여러 리스너 등록, 지역별 몬스터 그룹 관리, 특정 태그에 해당하는 여러 객체 관리 등 일대다 관계를 표현할 때 적합합니다.



### 문자열 정의

**FName, FString, FText는 어떤 차이가 있고 각각 언제 사용하는 것이 좋을까요?**

FName : 불변(immutable)하고 대소문자를 구분하지 않는 문자열로, 내부적으로 정수 ID로 변환되어 관리됩니다. 문자열 비교 연산이 매우 빠르고 메모리 사용이 효율적입니다. 적합한 사용 사례는 태그, 식별자, 에셋 경로, 소켓 이름 등 자주 비교 연산이 필요하고 변경되지 않는 문자열에 적합합니다.

FString : 일반적인 가변 문자열로 문자열 조작(연결, 치환, 분할 등)이 필요할 때 사용합니다. 다양한 문자열 처리 함수를 제공하며 UTF-16 인코딩을 사용합니다. 적합한 사용 사례는 동적으로 생성되는 문자열, 파일 경로, 임시 문자열 연산, 디버그 메시지 등 문자열 조작이 필요한 경우에 적합합니다.

FText : 지역화(Localization)를 지원하는 문자열로, 게임 내 사용자에게 표시되는 모든 텍스트에 사용해야 합니다. 불변성을 가지며 다국어 지원을 위한 추가 기능이 포함되어 있습니다. 적합한 사용 사례는 UI 텍스트, 대화 내용, 아이템 설명, 퀘스트 텍스트 등 사용자에게 보여지는 모든 텍스트와 다국어 지원이 필요한 경우에 적합합니다.

성능과 메모리 사용 측면에서는 FName이 가장 효율적이고, 그 다음이 FString, FText 순입니다. 따라서 상황에 맞게 적절한 타입을 선택하는 것이 중요합니다.

---

## 단계 3 : 객체지향 및 언리얼 구조 이해

### 가상 함수 동작 방식과 vtable의 역할

**가상 함수는 어떻게 동작하나요? vtable은 어떤 역할을 하나요?**

가상 함수는 C++의 다형성을 구현하는 핵심 메커니즘입니다. 클래스에 virtual 키워드로 선언된 함수는 런타임에 동적으로 바인딩되어, 실제 객체의 타입에 맞는 함수가 호출됩니다.

작동 방식은 다음과 같습니다

* 클래스에 가상 함수가 선언되면, 컴파일러는 해당 클래스를 위한 vtable(가상 함수 테이블)을 생성합니다.

* vtable은 클래스의 모든 가상 함수에 대한 포인터를 저장하는 배열입니다.

* 각 객체는 vptr(가상 함수 테이블 포인터)을 가지며, 이는 해당 클래스의 vtable을 가리킵니다.

* 가상 함수 호출 시, 프로그램은 객체의 vptr을 통해 vtable에 접근하고, 함수의 올바른 구현을 찾아 호출합니다.

vtable의 역할은 다음과 같습니다.

* 런타임에 올바른 함수 구현을 찾아주는 룩업 테이블 역할을 합니다.

* 다형성을 효율적으로 구현할 수 있게 해주며, 실행 시간에 올바른 함수를 호출할 수 있도록 합니다.

* 각 클래스마다 하나의 vtable이 존재하며, 해당 클래스의 모든 인스턴스가 공유합니다.

이 메커니즘 덕분에 기본 클래스 포인터로 파생 클래스 객체를 참조할 때도 파생 클래스의 오버라이드된 함수가 호출될 수 있습니다.



### RTTI와 dynamic_cast, typeid 사용처

**RTTI는 무엇인가요? dynamic_cast와 typeid는 언제 사용하나요?**

RTTI(Run-Time Type Information)는 C++에서 객체의 타입을 런타임에 확인할 수 있게 해주는 기능입니다. 주로 다형성을 활용하는 코드에서 객체의 실제 타입을 안전하게 확인하고자 할 때 사용됩니다.

RTTI의 주요 구성 요소

* dynamic_cast : 런타임에 안전한 다운캐스팅을 수행합니다. 기본 클래스 포인터나 참조를 파생 클래스 타입으로 변환할 때 사용하며, 변환이 유효하지 않을 경우 포인터는 nullptr을 반환하고, 참조는 std::bad_cast 예외를 발생시킵니다.

* typeid : 객체의 실제 타입 정보를 반환합니다. std::type_info 객체를 반환하며, 이를 통해 타입 이름을 얻거나 타입을 비교할 수 있습니다.

사용 시점

* dynamic_cast는 다형적 클래스 계층에서 안전한 타입 변환이 필요할 때 사용합니다. 예를 들어, 컨테이너에 기본 클래스 포인터로 저장된 객체들 중 특정 파생 클래스 타입만 골라내야 할 때 유용합니다.

* typeid는 객체의 정확한 타입을 확인해야 할 때 사용합니다. 주로 디버깅이나 타입에 따른 분기 처리가 필요한 경우에 활용됩니다.

다만, RTTI는 성능 오버헤드가 있으므로 꼭 필요한 경우에만 사용하는 것이 좋습니다. 가능하면 가상 함수를 통한 다형성을 활용하는 것이 더 객체지향적인 접근 방식입니다.



### 리플렉션 시스템과 CDO와의 관계, UPROPERTY와 UFUNCTION의 역할

**언리얼 엔진의 리플렉션 시스템이란 무엇인가요? CDO와의 관계는 무엇인가요? UPROPERTY, UFUNCTION은 어떤 역할을 하나요?**

언리얼 엔진의 리플렉션 시스템은 C++ 클래스와 프로퍼티에 대한 런타임 타입 정보를 제공하는 메커니즘입니다. 이를 통해 에디터 UI, 네트워크 직렬화, 블루프린트 노출 등 다양한 기능이 가능해집니다.

리플렉션 시스템의 핵심 구성요소

* UPROPERTY : 클래스 멤버 변수에 메타데이터를 추가하는 매크로입니다. 이를 통해 변수가 에디터에 노출되고, 네트워크 복제, 세이브 게임 지원, 가비지 컬렉션 참조 추적 등이 가능해집니다. 예를 들어, BlueprintReadWrite, Replicated, EditAnywhere 등의 지정자를 사용할 수 있습니다.

* UFUNCTION : 클래스 멤버 함수에 메타데이터를 추가하는 매크로입니다. 이를 통해 함수가 블루프린트에 노출되거나, RPC(원격 프로시저 호출)로 사용되거나, 이벤트로 바인딩될 수 있습니다. BlueprintCallable, Server, Client, NetMulticast 등의 지정자가 있습니다.

* UCLASS : 클래스에 메타데이터를 추가하여 언리얼 객체 시스템에 통합시키는 매크로입니다.

CDO(Class Default Object)와의 관계

* CDO는 각 UClass 타입마다 생성되는 기본 객체 인스턴스입니다.

* 리플렉션 시스템이 클래스를 등록할 때 해당 클래스의 CDO를 생성합니다.

* CDO는 해당 클래스의 기본 프로퍼티 값을 저장하고, 새 인스턴스 생성 시 템플릿으로 사용됩니다.

* 에디터에서 블루프린트를 편집할 때 기본값으로 표시되는 것이 CDO의 값입니다.

이 리플렉션 시스템 덕분에 언리얼은 강력한 비주얼 스크립팅, 네트워크 복제, 직렬화 등의 기능을 제공할 수 있습니다.



### Actor와 Pawn의 차이

**Actor와 Pawn의 차이점은 무엇인가요? 네트워크에서 이들이 어떻게 다르게 동작하나요?**

Actor와 Pawn은 언리얼 엔진의 주요 클래스로, 각각 다른 목적과 기능을 가지고 있습니다.

Actor와 Pawn의 차이점

* Actor는 게임 월드에 배치될 수 있는 가장 기본적인 객체 클래스입니다. 위치, 회전, 스케일 정보를 가지며, 월드와 상호작용할 수 있습니다. 예로는 StaticMeshActor, Light, Trigger 등이 있습니다.

* Pawn은 Actor를 상속받아 확장한 클래스로, 플레이어나 AI에 의해 제어될 수 있는 물리적 표현체입니다. 주요 특징은 Controller 클래스와 연결되어 입력을 받아 처리할 수 있다는 점입니다. Character 클래스는 Pawn을 더 확장하여 이동, 점프 등의 기능이 추가된 클래스입니다.

네트워크에서의 동작 차이는 다음과 같습니다.

Actor의 네트워크 동작

* 기본적으로 모든 Actor는 복제(Replication)될 수 있지만, 명시적으로 bReplicates = true로 설정해야 합니다.

* Actor는 주로 속성(Property) 복제에 초점을 맞추며, RPC를 통해 함수 호출을 네트워크로 전달할 수 있습니다.

* 일반적으로 서버가 Actor의 상태를 소유하고 클라이언트에게 전파합니다.

Pawn의 네트워크 동작

* Pawn은 특별한 소유권(Ownership) 개념이 추가됩니다. 각 Pawn은 특정 PlayerController에 의해 소유될 수 있습니다.

소유된 Pawn은 해당 클라이언트에게 우선권이 부여되며, 클라이언트 권한 모델(Client Authority)이 적용될 수 있습니다.

* 클라이언트는 자신이 소유한 Pawn에 대해 서버로 입력을 전송하고, 서버는 이를 처리한 후 결과를 모든 클라이언트에게 복제합니다.

* 네트워크 지연을 보완하기 위해 클라이언트 사이드 예측(Client-Side Prediction)과 서버 보정(Server Correction)이 적용됩니다.

이러한 차이로 인해 Pawn은 주로 플레이어나 AI가 제어하는 캐릭터에 사용되고, Actor는 더 일반적인 게임 객체에 사용됩니다. 네트워크 게임에서는 이 차이를 이해하고 적절히 활용하는 것이 중요합니다.



### 언리얼 엔진 가비지 컬렉션

**언리얼 엔진의 Garbage Collection은 어떤 방식으로 작동하나요? 수거되지 않는 객체는 어떤 경우에 생기고 어떻게 해결하나요?**

언리얼 엔진의 가비지 컬렉션(GC)은 더 이상 참조되지 않는 UObject들을 자동으로 식별하고 메모리에서 해제하는 시스템입니다.

작동 방식은 아래와 같습니다.

* 루트 집합(Root Set) 식별 : GC는 루트 객체(예: 레벨, 게임 인스턴스, 플레이어 컨트롤러 등)에서 시작합니다.

* 참조 추적(Reference Tracing) : 루트 객체부터 시작해 UPROPERTY 매크로로 표시된 모든 참조를 따라가며 도달 가능한 객체들을 표시합니다.

* 마킹(Marking) : 도달 가능한 객체들은 살아있는 것으로 표시됩니다.

* 스위핑(Sweeping) : 표시되지 않은 객체들은 더 이상 접근할 수 없다고 판단되어 메모리에서 해제됩니다.

* 클러스터링(Clustering) : 최신 버전에서는 관련 객체들을 클러스터로 그룹화하여 GC 성능을 최적화합니다.

수거되지 않는 객체가 발생하는 경우는 아래와 같습니다.

* UPROPERTY가 아닌 포인터로 참조 : UPROPERTY 매크로 없이 일반 포인터로 객체를 참조하면 GC가 이를 인식하지 못합니다.

* 순환 참조 : 객체 A가 객체 B를 참조하고, 객체 B가 다시 객체 A를 참조하는 경우, 둘 다 루트에서 도달할 수 없게 되면 메모리 누수가 발생할 수 있습니다.

* 네이티브 코드에서의 참조 : C++ 측에서 언리얼 객체 시스템 외부의 컨테이너나 구조체가 UObject 참조를 저장하는 경우입니다.

* AddReferencedObjects 오버라이드 : 이 메서드를 사용해 수동으로 객체 참조를 추가했으나 제대로 관리하지 않는 경우입니다.

해결 방법은 아래와 같습니다.

* UPROPERTY 사용 : 모든 UObject 참조는 UPROPERTY 매크로로 표시해야 합니다.

* 약한 참조 활용 : TWeakObjectPtr을 사용하여 순환 참조 문제를 해결할 수 있습니다.

* 명시적 참조 해제 : 객체 사용이 끝났을 때 nullptr를 할당하여 참조를 명시적으로 해제합니다.

* 언리얼 컨테이너 사용 : TArray, TMap과 같은 언리얼의 컨테이너 클래스를 사용하고 UPROPERTY로 표시합니다.

* UE_LOG와 stat 명령어 활용 : 메모리 누수를 디버깅하기 위해 로그와 통계 명령어를 활용할 수 있습니다.

메모리 관리는 게임 성능과 안정성에 중요한 영향을 미치므로, 언리얼의 GC 시스템을 잘 이해하고 적절히 활용하는 것이 중요합니다.

---

## 단계 4 : AI 및 콘텐츠 생성 시스템 이해

### 언리얼의 절차적 콘텐츠 생성(PCG) 시스템

**언리얼의 절차적 콘텐츠 생성(PCG) 시스템이 무엇인지 설명해보세요. 어떤 경우에 사용하면 효과적인가요?**

언리얼의 절차적 콘텐츠 생성(PCG) 시스템은 알고리즘과 규칙을 통해 자동으로 게임 콘텐츠를 생성하는 도구입니다. 언리얼 엔진 5에서는 PCG 프레임워크를 통해 개발자가 보다 쉽게 절차적 콘텐츠를 만들 수 있도록 지원합니다.

PCG 시스템의 주요 특징으로는

* 노드 기반 그래프 인터페이스로 직관적인 워크플로우 구성이 가능합니다.

* 다양한 생성 알고리즘(보로노이, 노이즈 등)을 내장하고 있습니다.

* 실시간 미리보기와 빠른 반복 작업이 가능합니다.

* 기존 콘텐츠와 통합하여 하이브리드 접근법도 가능합니다.

PCG가 효과적인 상황

* 대규모 오픈 월드 : 넓은 지형, 식생, 도로망 등을 수작업으로 제작하기 어려운 경우

* 무작위성이 필요한 게임 : 로그라이크, 생존 게임 등 매 플레이마다 다른 경험을 제공해야 하는 경우

* 반복적인 환경 요소 : 숲, 산맥, 도시 구조 등 비슷한 패턴이 반복되는 환경

* 리소스 최적화 : 한정된 개발 인력으로 대량의 콘텐츠를 생성해야 할 때

* 실시간 적응형 콘텐츠 : 플레이어의 행동이나 스킬 레벨에 따라 동적으로 난이도를 조절하는 경우



### Behavior Tree를 이용한 AI 구성 경험

**Behavior Tree를 이용한 AI 구성 경험이 있다면 설명해보세요. (Blackboard, Service, Decorator, Task 중심)**

Behavior Tree를 활용한 AI 구성 경험에 대해 말씀드리겠습니다. 최근 프로젝트에서 NPC 행동 패턴을 설계할 때 Behavior Tree를 사용했습니다.

주요 구성 요소별 접근 방식은 다음과 같습니다

* Blackboard : AI의 메모리 역할을 하는 블랙보드에는 타겟 액터, 목적지 위치, 체력 상태, 경계 상태 등 의사결정에 필요한 핵심 데이터를 저장했습니다. 특히 플레이어 감지 여부를 'CanSeePlayer' 변수로 관리하여 상태 전환의 기준으로 삼았습니다.

* Service : 일정 주기로 실행되는 서비스 노드를 통해 주변 환경을 감지하고 블랙보드 값을 갱신했습니다. 예를 들어 'ScanEnvironment' 서비스는 0.5초마다 실행되어 시야 내 플레이어 존재 여부를 확인하고 그 결과를 블랙보드에 업데이트했습니다.

* Decorator : 조건 분기를 위해 데코레이터를 활용했습니다. 'IsHealthLow' 데코레이터는 체력이 30% 이하일 때만 하위 노드를 실행하도록 했고, 'IsPlayerVisible' 데코레이터는 플레이어가 시야에 있을 때만 공격 시퀀스를 실행하도록 설정했습니다.

* Task : 실제 행동을 정의하는 태스크 노드에서는 'MoveToLocation', 'PlayAttackAnimation', 'FindCover' 등 구체적인 행동을 구현했습니다. 특히 복잡한 행동은 C++로 커스텀 태스크를 만들어 Blueprint에서 재사용할 수 있게 했습니다.



### Behavior Tree와 StateTree의 차이점과 장점

**Behavior Tree와 StateTree는 어떤 차이가 있으며, 각각의 장점은 무엇이라고 생각하나요?**

Behavior Tree와 StateTree는 AI 구현을 위한 접근법으로, 각각 다음과 같은 차이점과 장점이 있습니다

Behavior Tree

* 구조적 특징 : 트리 형태의 계층적 구조로, 상위 노드에서 하위 노드로 실행 흐름이 전달됩니다.

* 실행 방식 : Selector(OR), Sequence(AND) 등의 컴포지트 노드를 통해 복잡한 의사결정 로직을 구현합니다.

장점

* 시각적 디버깅이 용이하여 복잡한 AI 로직도 직관적으로 이해할 수 있습니다.

* 재사용성이 높아 서브트리를 통해 공통 행동 패턴을 여러 AI에 적용할 수 있습니다.

* 비게임 프로그래머도 비교적 쉽게 AI 로직을 수정할 수 있습니다.

StateTree

* 구조적 특징 : 명확한 상태와 전이 조건으로 구성된 유한 상태 기계(FSM) 기반 시스템입니다.

* 실행 방식 : 항상 하나의 상태만 활성화되며, 조건 충족 시 다른 상태로 전환됩니다.

장점

* 상태 간 전환이 명확하여 예측 가능한 행동 패턴을 만들기 좋습니다.

* 오버헤드가 적어 성능 면에서 Behavior Tree보다 효율적일 수 있습니다.

* 단순한 AI나 상태 기반 로직에 적합하며 구현이 직관적입니다.

개인적으로는 상황에 따라 두 시스템의 장점을 조합하는 접근법이 효과적이라고 생각합니다. 예를 들어, 상위 수준의 의사결정은 StateTree로 관리하고(순찰, 추격, 공격 등의 주요 상태), 각 상태 내부의 세부 행동은 Behavior Tree로 구현하는 하이브리드 방식이 복잡한 AI 시스템에 적합할 수 있습니다.



### 디버깅 과정에서 겪은 문제와 해결 경험

**Behavior Tree나 StateTree 디버깅 과정에서 겪은 문제와 해결 경험이 있다면 설명해보세요.**

Behavior Tree 디버깅 과정에서 겪었던 가장 큰 문제는 AI가 예상치 못한 방식으로 행동하는 '상태 오실레이션' 현상이었습니다. NPC가 추격과 순찰 상태 사이를 빠르게 왔다갔다하는 문제가 발생했습니다.

문제 분석과 해결 과정은 다음과 같았습니다

* 원인 파악 : Behavior Tree 디버거를 활용해 실시간으로 노드 실행 흐름을 추적했습니다. 문제는 플레이어 감지 조건이 경계선에서 너무 자주 변경되어 상태 전환이 빈번하게 일어나는 것이었습니다.

해결 접근법

* '히스테리시스(Hysteresis)' 개념을 적용했습니다. 상태 전환에 필요한 진입 조건과 이탈 조건에 차이를 두어 불필요한 상태 전환을 방지했습니다.

* '쿨다운 타이머'를 구현하여 상태 변경 후 일정 시간 동안은 다시 상태가 변경되지 않도록 했습니다.

* 블랙보드 값 갱신에 '스무딩'을 적용하여 순간적인 변화가 아닌 일정 기간의 평균값을 사용했습니다.

* 검증 및 최적화 : 수정 후 다양한 상황에서 AI 행동을 테스트하고, Behavior Tree 프로파일러를 통해 성능 병목 지점을 찾아 최적화했습니다. 특히 과도하게 복잡했던 조건 체크를 간소화하고, 빈번한 블랙보드 업데이트 주기를 조정했습니다.

이 경험을 통해 AI 시스템 설계 시 상태 전환의 안정성을 고려하는 것이 중요하다는 것을 배웠고, 디버깅 도구의 효과적인 활용법과 함께 로깅 시스템의 중요성도 깨달았습니다. 이후 프로젝트에서는 초기 설계 단계에서부터 이러한 문제를 예방하기 위한 장치를 마련하고 있습니다.

---

## 단계 5 : 네트워크 구조와 실전 문제 해결 능력

### 언리얼 서버 구조(데디케이티드 서버)

**언리얼의 서버 구조(데디케이티드 서버)에 대해 설명해보세요. RPC와 Replication은 어떻게 작동하나요?**

언리얼 엔진의 데디케이티드 서버는 클라이언트와 완전히 분리된 독립적인 서버 인스턴스로, 게임 로직의 권위적 처리와 클라이언트 간 상태 동기화를 담당합니다. 주요 특징으로는 다음과 같습니다.

* UI나 렌더링 관련 코드가 제외된 경량화된 구조로, 리소스 효율성이 높습니다.

* 권위적 게임플레이 처리로 클라이언트 치팅을 방지합니다.

* 클라이언트-서버 아키텍처로 확장성이 높고 대규모 멀티플레이어 지원이 가능합니다.

RPC(Remote Procedure Call)와 Replication은 서버-클라이언트 간 통신의 핵심 메커니즘입니다

RPC 시스템

* 클라이언트에서 서버로(Client to Server), 서버에서 클라이언트로(Server to Client), 또는 멀티캐스트 방식으로 함수 호출을 가능하게 합니다.

* UFUNCTION 매크로의 다양한 지정자(Reliable, Unreliable, Server, Client, NetMulticast)를 통해 네트워크 호출 방식을 정의합니다.

* Reliable은 패킷 전달을 보장하지만 오버헤드가 크고, Unreliable은 빠르지만 패킷 손실 가능성이 있습니다.

Replication 시스템

* 서버에서 관리하는 객체와 변수의 상태를 클라이언트에게 자동으로 동기화합니다.

* UPROPERTY 매크로의 Replicated 지정자로 변수 복제를 설정하고, ReplicatedUsing으로 값 변경 시 콜백 함수를 호출할 수 있습니다.

* Replication Condition을 통해 COND_OwnerOnly, COND_AutonomousOnly 등 복제 조건을 세밀하게 제어할 수 있습니다.

이 두 시스템을 적절히 활용하여 네트워크 대역폭을 최적화하고 지연 시간을 최소화하는 것이 멀티플레이어 게임 개발의 핵심입니다.



### 프로젝트 문제 해결 경험

**프로젝트나 과제를 하면서 마주쳤던 문제 중 기억에 남는 것을 설명하고 어떻게 해결했는지 이야기해보세요.**

대학 졸업 작품으로 언리얼 엔진을 처음 사용하며 개발했던 프로젝트에서 가장 기억에 남는 문제는 다수의 AI 캐릭터가 등장하는 전투 시스템에서 발생한 성능 병목 현상이었습니다.

문제 상황

* 전투 중 20여 개의 AI 캐릭터가 동시에 행동할 때 프레임 레이트가 급격히 떨어지는 현상이 발생했습니다.

* 특히 AI의 시야 감지와 경로 탐색 과정에서 CPU 사용량이 급증했습니다.

분석 과정

* 언리얼의 프로파일링 툴을 활용하여 병목 지점을 정확히 파악했습니다.

* 모든 AI가 매 프레임마다 복잡한 시야 체크와 경로 계산을 수행하고 있었습니다.

해결 방법

* AI 업데이트 빈도를 조절하는 LOD(Level of Detail) 시스템을 구현했습니다. 플레이어와의 거리에 따라 업데이트 주기를 차등 적용했습니다.

* 시야 감지 로직을 최적화하여 불필요한 연산을 줄였고, 경로 탐색은 결과를 캐싱하여 재사용했습니다.

* Behavior Tree의 Service 노드 실행 주기를 조절하고, 계산 비용이 큰 태스크는 비동기 처리로 변경했습니다.

결과

* 최적화 후 동일 상황에서 프레임 레이트가 3배 이상 향상되었습니다.

* CPU 사용량이 크게 감소하여 다른 게임플레이 요소를 추가할 여유가 생겼습니다.

* 이 경험을 통해 실시간 성능 최적화의 중요성과 프로파일링 기반 문제 해결 접근법의 효과를 직접 체험할 수 있었습니다. 또한 언리얼 엔진의 AI 시스템에 대한 이해도를 크게 높이는 계기가 되었습니다.



### AI 도구 활용 경험

**공부를 하면서 AI 도구(예: ChatGPT, GitHub Copilot 등)를 활용해본 경험이 있다면 어떤 점이 유용했는지 공유해주세요.**

AI 도구들은 게임 개발 학습과 프로젝트 진행에 있어 다양한 방식으로 도움이 되었습니다

코드 작성 및 디버깅

* GitHub Copilot을 활용해 반복적인 보일러플레이트 코드 작성 시간을 단축했습니다. 특히 언리얼의 클래스 선언부와 같은 정형화된 코드 생성에 효과적이었습니다.

* 버그 발생 시 에러 메시지를 ChatGPT에 입력하여 원인 분석과 해결 방향을 빠르게 파악할 수 있었습니다.

알고리즘 및 패턴 학습

* 게임 개발에 필요한 특정 알고리즘(A* 경로탐색, 충돌 감지 등)의 개념과 구현 방법을 ChatGPT를 통해 학습했습니다.

* 디자인 패턴을 실제 게임 코드에 적용하는 방법을 이해하는 데 도움을 받았습니다.

언리얼 엔진 API 이해

* 방대한 언리얼 엔진 API 중 특정 기능의 사용법과 예제를 찾는 데 ChatGPT가 유용했습니다.

* 공식 문서만으로는 이해하기 어려운 복잡한 개념(네트워킹, GAS 등)을 더 쉽게 파악할 수 있었습니다.

리팩토링 및 코드 최적화

* 기존 코드를 더 효율적이고 가독성 높은 형태로 리팩토링하는 방법을 제안받아 코드 품질을 향상시켰습니다.

* 성능 최적화를 위한 다양한 접근법을 탐색하는 데 도움을 받았습니다.

다만, AI 도구 활용 시 항상 출력 결과를 비판적으로 검토하는 습관을 들였습니다. 때로는 잘못된 정보나 최신 엔진 버전에 맞지 않는 답변이 제공될 수 있기 때문입니다. AI 도구는 참고 자료로 활용하고, 최종 판단과 적용은 직접 검증 후 진행했습니다.

이러한 AI 도구 활용 경험은 개발 효율성을 높이는 동시에, 문제 해결 능력과 기술적 이해도를 더욱 향상시키는 데 기여했다고 생각합니다.