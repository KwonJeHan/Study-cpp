# C++ 학습 정리

**2025/01/06 [포텐업] 게임 개발자 양성 과정**

---

### 스마트 포인터

자바나 C# 등의 최신 언어는 가비지 컬렉터를 지원하지만, C++는 기본적으로 가비지 컬렉터가 없다. 대신 C++는 STL을 통해 메모리를 알아서 해제 해주는 똑똑한 포인터를 지원한다.



크게 세 가지가 있다.

* uniaue_ptr : 가장 기본이 되는 포인터로 단일 소유자만 허용한다. 새로운 소유자로 이동은 가능하지만 복사나 공유는 불가능하다.

* shared_ptr : 참조 횟수가 계산되는 포인터로 원시 포인터 하나를 여러 소유자에게 할당(공유)하려는 경우 사용한다. (원시 포인터는 모든 shared_ptr 소유자의 소유권이 해제될 때까지 삭제되지 않는다.)
* weak_ptr : shared_ptr과 함께 사용할 수 있는 특별한 유형의 포인터로 shared_ptr이 소유하는 포인터에 대한 접근은 제공하지만, 참조 횟수에 포함되지 않는다. shared_ptr 사용 시 발생할 수 있는 순환 참조를 해결하기 위해 사용하는 경우가 많다.



#### unique_ptr 기본

**포인터를 공유하지 않는다.**

다른 함수에 복사하거나, 값으로 전달하거나 복사본을 생성해야 하는 STL 알고리즘에는 사용할 수 없다.

<memory> 헤더가 필요하며 원시 포인터만큼 가볍고 효율적이며, STL 컨테이너에서 사용할 수 있다.



#### unique_ptr 소유권 이전

std::move 함수를 사용해 소유권을 이전한다.

**주의사항**

* 소유권이 이전된 unique_ptr을 댕글링 포인터라고 하는데 댕글링 포인터를 사용하면 null이기 때문에 오류가 발생할 수 있다.
* 따라서 소유권을 이전할 때는 기존 포인터를 절대로 사용하지 않는다는 확신이 있을 때에만 진행한다.



#### unique_ptr을 함수로 전달

복사 생성자가 호출되는 상황 중 함수 호출 시 객체를 값에 의해 전달하는 경우가 있는데 unique_ptr은 복사 생성자를 명시적으로 삭제했기 때문에 함수에 값을 전달할 때 아래와 같이 다른 방법을 사용해야 한다.

**1. 포인터의 참조 전달**

**2. Raw 포인터 전달**

**3. 객체의 참조(레퍼런스) 전달**



#### shared_ptr 스마트 포인터

**여러 소유자를 허용하는 메모리 공간의 수명을 관리하기 위한 스마트 포인터**

shared_ptr을 초기화한 후 복사, 함수에 값으로 전달, 다른 shared_ptr 객체로 할당이 가능하다.



#### weak_ptr 스마트 포인터

shared_ptr은 스마트 포인터가 관리하는 객체의 참조 횟수가 0이 되면 메모리에서 해제한다.

그러나 서로 참조하는 shared_ptr은 참조 횟수가 0이 될 수 없는 상황이 발생하는데 이런 경우를 순환 참조라고 한다.

이런 문제를 해결하기 위해 도입된 것이 weak_ptr이다.

weak_ptr은 그 자체로는 사용할 수 없고 lock() 함수를 통해 shared_ptr로 변환해야 한다.
