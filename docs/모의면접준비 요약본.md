## ✅ [1단계] 언어 기초 및 시스템 이해

### 🔸 C vs C++ 차이

- **C는 절차지향**, 순차적 흐름에 따라 함수 호출 중심.
- **C++은 객체지향**, 캡슐화/상속/다형성을 지원.
- 게임 개발에선 **C++이 고성능 + 구조적 설계**를 동시에 지원하여 적합.

### 🔸 C++ 형변환 방식

- `static_cast`: 안전한 변환 (예: float → int, 부모 → 자식)
- `dynamic_cast`: RTTI 기반. 상속 관계에서 **런타임에 안전하게 다운캐스팅**
- `const_cast`: const 속성 제거. 일반적으로 위험하니 조심.
- `reinterpret_cast`: **비트 수준 포인터 변환**. 매우 위험, 드물게 하드웨어 연동 시 사용.

### 🔸 LValue, RValue, Universal Reference

- **LValue**: 변수처럼 메모리 주소 있는 값
- **RValue**: 임시 값. ex) `a + b`, `5`
- **Universal Reference (T&&)**: 템플릿에서 L/RValue 둘 다 참조 가능. `std::forward`와 함께 **퍼펙트 포워딩** 구현.

### 🔸 메모리 영역

- **Code**: 함수 기계어. 읽기 전용.
- **Data**: 전역/정적 변수
- **Stack**: 함수 호출 시 지역 변수. 크기 제한, 자동 해제.
- **Heap**: 동적 할당. new/delete 필요. **메모리 누수 주의**.

### 🔸 프로세스 vs 스레드

- **프로세스**: 메모리 공간 독립. 자원 분리.
- **스레드**: 프로세스 내부. **자원 공유**, 가볍고 빠름.
- 게임에서 스레드는 렌더링, 네트워크, 물리 등에 병렬 활용.

### 🔸 컨텍스트 스위칭

- CPU가 작업 스레드 전환 시 상태 저장/복원.
- 너무 자주 발생하면 **캐시 오염, 성능 저하**.

### 🔸 데드락 방지

- 4가지 조건 (상호배제, 점유-대기, 비선점, 순환대기) 모두 만족 시 발생.
- 해결: **자원 순서 고정, 타임아웃, 락 계층화, weak 참조 사용**

------

## ✅ [2단계] 메모리, 자료구조, 문자열

### 🔸 스마트 포인터 종류

- `unique_ptr`: 단일 소유. 이동만 가능. 기본 선택.
- `shared_ptr`: 공유 소유. 참조 카운트 자동 관리.
- `weak_ptr`: 참조만 가능. **순환 참조 방지**.

### 🔸 순환 참조 문제

- shared_ptr끼리 서로 참조하면 메모리 해제 안 됨.
- **한쪽을 weak_ptr로 바꿔야 함**.

### 🔸 언리얼 자료구조

- `TArray`: 동적 배열. 순차 접근, 인벤토리 등.
- `TMap`: 키-값. 빠른 검색 (ID → 객체)
- `TSet`: 중복 없음. 수집 아이템 목록 등.
- `TQueue`: 순서대로 처리 (예: 패킷, AI 명령 큐)
- `TMultiMap`: 하나의 키에 여러 값 가능.

### 🔸 FString / FName / FText

- `FString`: 문자열 가공용. 디버그용 등.
- `FName`: **불변**, 내부적으로 정수 ID. 빠른 비교.
- `FText`: 지역화 지원. **UI 표시용 문자열 전용**.

------

## ✅ [3단계] 언리얼 구조 및 객체지향

### 🔸 가상 함수 / vtable

- `virtual` 함수는 런타임에 **vtable을 통해 바인딩**.
- 객체는 `vptr`을 통해 자신의 vtable에 접근해 올바른 함수 호출.

### 🔸 RTTI, dynamic_cast, typeid

- RTTI: 런타임 타입 확인.
- `dynamic_cast`: 안전한 다운캐스트
- `typeid`: 실제 타입 정보 확인

### 🔸 UPROPERTY, UFUNCTION, 리플렉션

- `UPROPERTY`: GC 추적, 에디터 노출, 복제 등 메타데이터 부여.
- `UFUNCTION`: 네트워크 전송(RPC), 블루프린트 호출 가능.
- `CDO`: 클래스 기본값 보관 객체. 인스턴스 생성 시 기반이 됨.

### 🔸 Actor vs Pawn

- **Actor**: 월드 배치 가능한 일반 객체
- **Pawn**: **컨트롤러로 조작 가능**한 Actor. (예: 플레이어 캐릭터)

### 🔸 Garbage Collection

- 루트 객체 → UPROPERTY 따라 참조 추적 → 도달 안 된 객체 해제
- **UPROPERTY 누락, 일반 포인터 참조, 순환 참조** 주의

------

## ✅ [4단계] AI / 콘텐츠 생성

### 🔸 PCG 시스템 (Procedural Content Generation)

- 언리얼 5의 노드 기반 자동 콘텐츠 생성 툴.
- **대규모 맵, 반복 지형, 무작위 콘텐츠**에 유용.

### 🔸 Behavior Tree 구성 요소

- **Blackboard**: 변수 저장. (예: 타겟, 위치 등)
- **Service**: 주기적으로 환경 감지
- **Decorator**: 조건 판단
- **Task**: 행동 실행

### 🔸 BT vs StateTree

- **BT**: 트리 구조, 복잡한 의사결정 구현에 적합
- **StateTree**: 하나의 상태만 활성. 전이 조건 명확. 성능 좋음.

### 🔸 디버깅 문제 해결 경험

- AI가 상태 왔다갔다(오실레이션) → **히스테리시스**, **쿨다운 타이머**, **평균값 처리**로 안정화

------

## ✅ [5단계] 네트워크 & 실전

### 🔸 Dedicated Server 구조

- **UI 없이** 서버 전용 인스턴스. 게임 로직만 실행.
- **권위 서버 모델** → 클라이언트 치팅 방지.

### 🔸 RPC & Replication

- **RPC**: `UFUNCTION(Server, Reliable)` 등 지정
- **Replication**: `UPROPERTY(Replicated)`, 값 자동 전파
- **조건 설정**: `COND_OwnerOnly`, `COND_SkipOwner` 등

### 🔸 실전 문제 해결 경험 (AI 성능 병목)

- 20개 AI 등장 시 프레임 저하 → LOD 적용 + Service 주기 조절 + 캐싱 적용
- **최적화 후 3배 프레임 개선**

### 🔸 AI 도구 활용

- ChatGPT: API 사용법 확인, 디버깅 원인 파악, 최적화 조언
- GitHub Copilot: 반복 코드 자동 완성, 시간 절약