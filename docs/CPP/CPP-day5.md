# C++ 학습 정리

**2025/01/02 [포텐업] 게임 개발자 양성 과정**

---

### Value Category



#### L-value

**일반적으로 변수나 객체를 나타내고 메모리 위치를 가지며, 수정이 가능하다.**

```c++
int main()
{
	int x = 10;
}
```

x는 메모리 주소를 가지며, 값을 읽고 수정할 수 있다.



#### R-value

**임시 값으로서 메모리에 저장되지 않고 즉시 사용된다.**

```c++
int main()
{
	int x = 10;
	int y = x + 5;
}
```

10과 x + 5는 메모리에 저장되지 않고, 임시 값으로 사용된 후 사라진다.



#### L-Value Reference

L-value를 참조하는 데 사용한다. C++ 문법에서 레퍼런스라고 지칭하는 것이 L-value reference이다.

```c++
int main()
{
	int x = 10;
	int& ref = x;
	
	int& ref2 = 10;    // 오류 발생.
}
```

ref 변수는 x 변수를 참조한다. x 변수는 메모리 주소를 가지며 읽고, 쓸 수 있는 L-Value이기 때문에 L-Value Reference로 선언이 가능하다.

ref2 변수는 10을 참조한다. 하지만, 10은 메모리 주소가 없는 임시 값으로서 R-Value에 해당한다. L-Value Reference는 R-Value를 참조할 수 없기 때문에 오류가 발생한다.



#### R-value Refernece

R-value를 참조할 때 쓰며 & 대신 &&를 사용한다.

```c++
int main()
{
	int&& ref = 10;
}
```

위 코드에서 ref는 R-Value인 10을 참조하는 R-Value Reference다.

R-Value Reference는 임시 값을 다른 어딘가에 저장하는 목적으로 많이 활용된다. 이때 값을 복사(Copy)하는 대신 이동(Move)하는 방법으로 속도를 향상시킬 수 있다.



**이점**

복사가 아닌 메모리상의 이동이므로 메모리 할당, 복사, 해제를 줄여 프로그램의 성능 향상을 기대할 수 있다.



#### Move Semantics

**메모리 상의 이동을 의미한다.**

사용을 위해 Move 생성자와 Move 대입 연산자를 도입하며 인자는 R-value 참조(&&)이다. 이는 암묵적으로 생성되지 않으며 복사 생성자가 Move 생성자보다 우선순위가 높으며 대입 연산자가 Move 연산자보다 우선순위가 높다.



#### std::move

L-value를 R-value 참조로 하는 것은 불가능한데(기본적으로 R-value만 R-value 참조가 가능) 형 변환 시 R-value 참조로 만들 수 있다. 그것이 바로 std::move()이다.

**주의점**

- L-Value가 R-Value가 되어 임시 객체로 취급 받는다.
- std::move를 사용한 후의 객체는 보증할 수 없다.



**R-value 참조는 R-value가 아닌 L-value이다.**

따라서 R-value 참조는 R-value로 초기화해야 한다.



#### Perfect Forwarding

std::forward()로 L-Value는 L-Value로 R-Value는 R-Value로 형변환할 수 있다. 이는 템플릿 프로그래밍에서 유용하게 사용할 수 있다.



#### Move를 사용해야 하는 이유와 실체

반드시 Move를 사용해야만 하는 것은 아니다.

Move는 복사가 아닌 이동인데 기본적으로 얕은 복사를 하기 때문에 빠르다. 깊은 복사는 포인터가 참조하는 데이터도 복사하는데 반해, 얕은 복사는 포인터 변수(주소)만 복사하므로 빠르다.

C++ STL은 기본적으로 깊은 복사가 처리되도록 만들어졌는데 이 때문에 vector 등의 큰 크기를 복사하려면 비용이 많이 든다. 하지만 C++의 경우 얕은 복사는 메모리 이중 해제 등의 문제가 발생할 수 있다.

Move는 기본적으로 얕은 복사와 이중 해제를 방지하기 위해 뒤처리되는 일련의 과정이다. 다만 뒤처리 과정이 있기 때문에 const는  붙일 수 없고 const를 붙인 변수는 move를 해도 복사 생성자가 호출될 가능성이 있다.
